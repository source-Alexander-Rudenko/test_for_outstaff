## Что было сделано
Разработано асинхронный HTTP API для управления задачами, которые выполняются длительное время:  
Задачи создаются через API и сохраняются в память.
Каждая задача асинхронно отправляет  
запрос на внешний контейнер /slow-api:8081/slow, 
который отвечает спустя 3–5 секунд _ok_ или _fail_.  
Хранение задач реализовано в `map[string]*Task` с защитой через `RWMutex`.  
Поддерживаются CRUD операции: создание, получение, обновление, удаление задач.

При удалении выполняющейся задачи происходит отмена контекста `(context.CancelFunc)`.

API реализовано через Gorilla Mux.

## **Реализована чистая архитектура, она позволяет:**

### _Разделить ответственность:_

domain — сущности и бизнес-смысл (Task, TaskStatus)  
usecase — бизнес-логика, управление задачами  
repo — хранилище (в памяти), изолированное от логики  
delivery — HTTP слой (ввод/вывод)

### _Легко расширять:_

Заменить in-memory репозиторий на PostgreSQL, Redis, MongoDB — без изменения бизнес-логики тк все строится на интерфейсах.

### _Повышает тестируемость:_

Можем мокать репозитории и писать юнит-тесты для usecase без запуска сервера.

### Как можно улучшить приложение при росте аудитории
1. Заменить map на базу данных (PostgreSQL, SQLite, Redis).  
 Redis можно использовать как для хранения задач в работе, так и для разных токенов.

2. Авторизация и аутентификация.   Уже есть context, можно расширить:  
 добавлять userID, roles, token и передавать в usecase.

3. Сделать middleware для проверки токенов (JWT, OAuth2).

4. Добавить человеческое логирование через zap/logrus
5. Swagger документация.

### Запуск приложения 
Для удобства проверяющего сделал все-таки докер, и приложил конфиг коллекции для postman.

`docker compose up --build`